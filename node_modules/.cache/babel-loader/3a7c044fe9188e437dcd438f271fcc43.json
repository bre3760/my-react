{"ast":null,"code":"var _jsxFileName = \"/Users/brendanpolidori/Desktop/project_repos/my-react.nosync/learn-react/src/components/JsonParse.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useEffect } from 'react';\nimport axios from 'axios';\nimport Heatmap from './plots/Heatmap';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction JsonParse() {\n  _s();\n\n  const [cdmData, setCdmData] = useState([]);\n  useEffect(() => {\n    axios.get(`http://127.0.0.1:5000/api_cdm/available_data_test`) //.get(`http://127.0.0.1:5000/api_cdm/available_data`)\n    .then(res => {\n      // console.log(res)\n      setCdmData(res.data);\n    }).catch(err => {\n      console.log(err);\n    });\n  }, []);\n  console.log(cdmData);\n\n  function buildTimeLine(minimumMonthYear, maximumMonthYear) {\n    var dictOfTimeLines = {};\n    var timeLineArray = [];\n    var timeLineOfZeros = [];\n\n    for (let year = minimumMonthYear[\"year\"]; year <= maximumMonthYear[\"year\"]; year++) {\n      for (let month = 1; month < 13; month++) {\n        timeLineOfZeros.push(0);\n\n        if (month < 10) {\n          var topush = \"0\" + month.toString() + \"-\" + year.toString();\n        } else {\n          var topush = month.toString() + \"-\" + year.toString();\n        }\n\n        timeLineArray.push(topush);\n      }\n    }\n\n    dictOfTimeLines[\"timeLine\"] = timeLineArray;\n    dictOfTimeLines[\"timeLineZeros\"] = timeLineOfZeros;\n    return dictOfTimeLines;\n  }\n\n  function findMinMaxDates(json) {\n    var minMonthYear = {\n      \"year\": 3000,\n      \"month\": 12\n    };\n    var maxMonthYear = {\n      \"year\": 0,\n      \"month\": 0\n    };\n    var dictOfMinMaxDates = {};\n\n    for (var city_key in json) {\n      var allDataOfCity = json[city_key];\n      var sourcesForCity = [];\n\n      for (var datasource_key in allDataOfCity) {\n        var dataOfOneSource = [];\n        sourcesForCity.push(datasource_key);\n        dataOfOneSource = allDataOfCity[datasource_key];\n\n        for (var year_key in dataOfOneSource) {\n          var numberYear = parseInt(year_key);\n          var oneYearData = dataOfOneSource[year_key];\n\n          for (var month_key in oneYearData) {\n            var numberMonth = parseInt(month_key); // check min and max values of the dates\n\n            if (numberYear < minMonthYear[\"year\"]) {\n              minMonthYear[\"year\"] = numberYear;\n              minMonthYear[\"month\"] = numberMonth;\n            } else if (numberYear > maxMonthYear[\"year\"]) {\n              // new maximum\n              maxMonthYear[\"year\"] = numberYear;\n              maxMonthYear[\"month\"] = numberMonth;\n            } else if (numberYear === maxMonthYear[\"year\"] || numberYear === minMonthYear[\"year\"]) {\n              if (numberMonth < minMonthYear[\"month\"]) {\n                // this is the new minimum\n                minMonthYear[\"month\"] = numberMonth;\n              } //\n\n\n              if (numberMonth > maxMonthYear[\"month\"]) {\n                maxMonthYear[\"month\"] = numberMonth;\n              } //\n\n            } //\n\n          }\n        }\n      }\n    } // console.log(\"findMinMaxFunction\")\n    // console.log(minMonthYear,maxMonthYear)\n\n\n    dictOfMinMaxDates[\"maxMonthYear\"] = maxMonthYear;\n    dictOfMinMaxDates[\"minMonthYear\"] = minMonthYear;\n    return dictOfMinMaxDates;\n  }\n\n  function arrayConvert(json, dictOfMinMaxDates) {\n    var minMonthYear = dictOfMinMaxDates[\"minMonthYear\"];\n    var maxMonthYear = dictOfMinMaxDates[\"maxMonthYear\"]; // read the whole json once to find the whole timeline, it's ugly but should work\n    // build whole timelines\n\n    let timeLinesDict = buildTimeLine(minMonthYear, maxMonthYear);\n    var timeLine = timeLinesDict[\"timeLine\"];\n    var timeLineOfZeros = timeLinesDict[\"timeLineZeros\"]; //console.log(\"timelinezeros\",timeLineOfZeros)\n    // variables to return from the function\n\n    var dictOfCitiesTimeLineValues = {};\n    var cities_arr = [];\n    var valuesArrOfArr = []; // cycle all the cities\n\n    for (var city_key in json) {\n      var allDataOfCity = json[city_key]; // get the data for one city\n\n      var sourcesForCity = []; // this will contain the different source names for a city\n      // cycle all the sources\n\n      for (var datasource_key in allDataOfCity) {\n        var dataOfOneSource = [];\n        sourcesForCity.push(datasource_key); // push the name of the source to the list \n\n        dataOfOneSource = allDataOfCity[datasource_key]; // this is the data from one source \n\n        var totalDataForOneSouce = []; // cycle the data from one source \n\n        for (var year_key in dataOfOneSource) {\n          var numberYear = parseInt(year_key);\n          var oneYearData = dataOfOneSource[year_key];\n          var yearlyDataValues = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n          for (var month_key in oneYearData) {\n            var numberMonth = parseInt(month_key);\n            yearlyDataValues[numberMonth] = oneYearData[month_key];\n          } // this is not correct, years are not continuous\n\n\n          var diffYears = numberYear - minMonthYear[\"year\"]; // diffYears*12 in poi\n\n          var jj = 0;\n\n          for (let indextotalData = diffYears * 12 + 2; indextotalData < diffYears * 12 + 13; indextotalData++) {\n            timeLineOfZeros[indextotalData] = yearlyDataValues[jj];\n            jj = jj + 1;\n          }\n        } // end for on years\n\n\n        valuesArrOfArr.push(timeLineOfZeros);\n      } // end for one source\n      //console.log(totalDataForOneSouce)\n      // cycle through all the sources found and create the names for each aggregate\n\n\n      for (var i in sourcesForCity) {\n        cities_arr.push(city_key + \" \" + sourcesForCity[i]); //console.log(sourcesForCity[i])\n      }\n    } // end for on cities\n\n\n    dictOfCitiesTimeLineValues[\"cities\"] = cities_arr;\n    dictOfCitiesTimeLineValues[\"timeLine\"] = timeLine;\n    dictOfCitiesTimeLineValues[\"values\"] = valuesArrOfArr;\n    return dictOfCitiesTimeLineValues;\n  }\n\n  const theDates = findMinMaxDates(cdmData);\n  const dictfromjson = arrayConvert(cdmData, theDates);\n  console.log(dictfromjson[\"cities\"]);\n  console.log(dictfromjson[\"values\"]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(Heatmap, {\n      values: dictfromjson[\"values\"],\n      cities: dictfromjson[\"cities\"],\n      timeLine: dictfromjson[\"timeLine\"]\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 158,\n      columnNumber: 9\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 157,\n    columnNumber: 9\n  }, this);\n}\n\n_s(JsonParse, \"Rp4szxWOApMRlsnq1bYja4ln4n8=\");\n\n_c = JsonParse;\nexport default JsonParse;\n\nvar _c;\n\n$RefreshReg$(_c, \"JsonParse\");","map":{"version":3,"sources":["/Users/brendanpolidori/Desktop/project_repos/my-react.nosync/learn-react/src/components/JsonParse.js"],"names":["React","useState","useEffect","axios","Heatmap","JsonParse","cdmData","setCdmData","get","then","res","data","catch","err","console","log","buildTimeLine","minimumMonthYear","maximumMonthYear","dictOfTimeLines","timeLineArray","timeLineOfZeros","year","month","push","topush","toString","findMinMaxDates","json","minMonthYear","maxMonthYear","dictOfMinMaxDates","city_key","allDataOfCity","sourcesForCity","datasource_key","dataOfOneSource","year_key","numberYear","parseInt","oneYearData","month_key","numberMonth","arrayConvert","timeLinesDict","timeLine","dictOfCitiesTimeLineValues","cities_arr","valuesArrOfArr","totalDataForOneSouce","yearlyDataValues","diffYears","jj","indextotalData","i","theDates","dictfromjson"],"mappings":"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","sourcesContent":["import React, { useState, useEffect } from 'react'\nimport axios from 'axios'\nimport Heatmap from './plots/Heatmap'\n\nfunction JsonParse() {\n\n    const [cdmData, setCdmData] = useState([])\n\n    useEffect(() => {\n        axios\n            .get(`http://127.0.0.1:5000/api_cdm/available_data_test`)\n            //.get(`http://127.0.0.1:5000/api_cdm/available_data`)\n            .then(res => {\n                // console.log(res)\n                setCdmData(res.data)\n            })\n            .catch(err => {\n                console.log(err)\n            })\n    }, [])\n    console.log(cdmData)\n\n    function buildTimeLine(minimumMonthYear,maximumMonthYear) {\n        var dictOfTimeLines = {}\n        var timeLineArray = []\n        var timeLineOfZeros = []\n        for (let year = minimumMonthYear[\"year\"]; year <= maximumMonthYear[\"year\"]; year++) {\n            for (let month = 1; month < 13; month++) {\n                timeLineOfZeros.push(0)\n                if (month < 10) {\n                    var topush = \"0\"+month.toString()  + \"-\" + year.toString()\n                }else{\n                    var topush = month.toString()  + \"-\" + year.toString()\n                }\n                timeLineArray.push(topush)\n            }\n        }\n        dictOfTimeLines[\"timeLine\"] = timeLineArray\n        dictOfTimeLines[\"timeLineZeros\"] = timeLineOfZeros\n        return dictOfTimeLines;\n    }\n\n    \n    function findMinMaxDates(json) {\n        var minMonthYear = {\"year\":3000,\"month\":12}\n        var maxMonthYear = {\"year\":0,\"month\":0}\n        var dictOfMinMaxDates = {}\n        for(var city_key in json){\n            var allDataOfCity = json[city_key];\n            var sourcesForCity = [];\n            for(var datasource_key in allDataOfCity){\n                var dataOfOneSource = []\n                sourcesForCity.push(datasource_key)\n                dataOfOneSource = allDataOfCity[datasource_key]\n                for (var year_key in dataOfOneSource){\n                    var numberYear = parseInt(year_key)\n                    var oneYearData = dataOfOneSource[year_key]\n                    for (var month_key in oneYearData) {\n                        var numberMonth = parseInt(month_key)\n                        // check min and max values of the dates\n                        if ( numberYear < minMonthYear[\"year\"]  ) {\n                            minMonthYear[\"year\"] = numberYear\n                            minMonthYear[\"month\"] = numberMonth\n                        } else if (  numberYear > maxMonthYear[\"year\"] ) {\n                            // new maximum\n                            maxMonthYear[\"year\"] = numberYear\n                            maxMonthYear[\"month\"] = numberMonth\n                        } else if(numberYear === maxMonthYear[\"year\"] || numberYear === minMonthYear[\"year\"] ) {\n                            if (numberMonth < minMonthYear[\"month\"]) {\n                                // this is the new minimum\n                                minMonthYear[\"month\"] = numberMonth\n                            }//\n                            if (numberMonth > maxMonthYear[\"month\"]) {\n                                maxMonthYear[\"month\"] = numberMonth\n                            }//\n                        }//\n                    }\n                }\n            }\n        }\n        // console.log(\"findMinMaxFunction\")\n        // console.log(minMonthYear,maxMonthYear)\n        dictOfMinMaxDates[\"maxMonthYear\"] = maxMonthYear\n        dictOfMinMaxDates[\"minMonthYear\"] = minMonthYear\n        return dictOfMinMaxDates\n    }\n\n    \n    function arrayConvert(json,dictOfMinMaxDates){\n        var minMonthYear = dictOfMinMaxDates[\"minMonthYear\"]\n        var maxMonthYear = dictOfMinMaxDates[\"maxMonthYear\"]\n        // read the whole json once to find the whole timeline, it's ugly but should work\n        \n        // build whole timelines\n        let timeLinesDict = buildTimeLine(minMonthYear,maxMonthYear)\n        var timeLine = timeLinesDict[\"timeLine\"]\n        var timeLineOfZeros = timeLinesDict[\"timeLineZeros\"]\n        //console.log(\"timelinezeros\",timeLineOfZeros)\n        // variables to return from the function\n        var dictOfCitiesTimeLineValues = {}\n        var cities_arr = [];\n        var valuesArrOfArr = [];\n        // cycle all the cities\n        for(var city_key in json){\n            var allDataOfCity = json[city_key]; // get the data for one city\n            var sourcesForCity = []; // this will contain the different source names for a city\n            \n            // cycle all the sources\n            for(var datasource_key in allDataOfCity){\n                var dataOfOneSource = []\n                sourcesForCity.push(datasource_key) // push the name of the source to the list \n                dataOfOneSource = allDataOfCity[datasource_key] // this is the data from one source \n                var totalDataForOneSouce = []\n                // cycle the data from one source \n                for (var year_key in dataOfOneSource) {\n                    var numberYear = parseInt(year_key)\n                    var oneYearData = dataOfOneSource[year_key]\n                    var yearlyDataValues = [0,0,0,0,0,0,0,0,0,0,0,0]\n                    for (var month_key in oneYearData) {\n                        var numberMonth = parseInt(month_key)\n                        yearlyDataValues[numberMonth] = oneYearData[month_key]\n                    }\n                    // this is not correct, years are not continuous\n                    var diffYears = numberYear - minMonthYear[\"year\"] \n                    // diffYears*12 in poi\n                    var jj = 0\n                    for (let indextotalData = diffYears*12 +2 ; indextotalData < diffYears*12 + 13; indextotalData++) {\n                        timeLineOfZeros[indextotalData] = yearlyDataValues[jj]\n                        jj = jj+1\n                    }\n                }// end for on years\n\n                valuesArrOfArr.push(timeLineOfZeros)\n            }// end for one source\n            //console.log(totalDataForOneSouce)\n            \n\n            // cycle through all the sources found and create the names for each aggregate\n            for(var i in sourcesForCity){\n                cities_arr.push(city_key + \" \" + sourcesForCity[i]);\n                //console.log(sourcesForCity[i])\n            }\n            \n        }// end for on cities\n        dictOfCitiesTimeLineValues[\"cities\"] = cities_arr;\n        dictOfCitiesTimeLineValues[\"timeLine\"] = timeLine;\n        dictOfCitiesTimeLineValues[\"values\"] = valuesArrOfArr;\n        return dictOfCitiesTimeLineValues;\n    }\n\n    const theDates = findMinMaxDates(cdmData);\n    const dictfromjson = arrayConvert(cdmData,theDates)\n    \n    console.log(dictfromjson[\"cities\"])\n    console.log(dictfromjson[\"values\"])\n    return (\n        <div>\n        <Heatmap values = {dictfromjson[\"values\"]} cities = {dictfromjson[\"cities\"]} timeLine = {dictfromjson[\"timeLine\"]}  ></Heatmap>\n        </div>\n    )\n}\n\n\nexport default JsonParse"]},"metadata":{},"sourceType":"module"}