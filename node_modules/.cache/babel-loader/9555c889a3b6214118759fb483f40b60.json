{"ast":null,"code":"var _jsxFileName = \"/Users/brendanpolidori/Desktop/project_repos/my-react.nosync/learn-react/src/components/JsonParse.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useEffect } from 'react';\nimport axios from 'axios';\nimport Heatmap from './plots/Heatmap';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction JsonParse() {\n  _s();\n\n  const [cdmData, setCdmData] = useState([]);\n  useEffect(() => {\n    axios.get(`http://127.0.0.1:5000/api_cdm/available_data_test`) //.get(`http://127.0.0.1:5000/api_cdm/available_data`)\n    .then(res => {\n      // console.log(res)\n      setCdmData(res.data);\n    }).catch(err => {\n      console.log(err);\n    });\n  }, []);\n  console.log(cdmData);\n\n  function buildTimeLine(minimumMonthYear, maximumMonthYear) {\n    var dictOfTimeLines = {};\n    var timeLineArray = [];\n    var timeLineOfZeros = [];\n\n    for (let year = minimumMonthYear[\"year\"]; year <= maximumMonthYear[\"year\"]; year++) {\n      for (let month = 1; month < 13; month++) {\n        timeLineOfZeros.push(0);\n\n        if (month < 10) {\n          var topush = \"0\" + month.toString() + \"-\" + year.toString();\n        } else {\n          var topush = month.toString() + \"-\" + year.toString();\n        }\n\n        timeLineArray.push(topush);\n      }\n    }\n\n    dictOfTimeLines[\"timeLine\"] = timeLineArray;\n    dictOfTimeLines[\"timeLineZeros\"] = timeLineOfZeros;\n    return dictOfTimeLines;\n  }\n\n  var minMonthYear = {\n    \"year\": 3000,\n    \"month\": 12\n  };\n  var maxMonthYear = {\n    \"year\": 0,\n    \"month\": 0\n  };\n\n  function arrayConvert(json) {\n    // read the whole json once to find the whole timeline, it's ugly but should work\n    for (var city_key in json) {\n      for (var datasource_key in allDataOfCity) {\n        for (var year_key in dataOfOneSource) {\n          for (var month_key in oneYearData) {\n            var numberMonth = parseInt(month_key); // check min and max values of the dates\n\n            if (numberYear < minMonthYear[\"year\"]) {\n              minMonthYear[\"year\"] = numberYear;\n              minMonthYear[\"month\"] = numberMonth;\n            } else if (numberYear > maxMonthYear[\"year\"]) {\n              // new maximum\n              maxMonthYear[\"year\"] = numberYear;\n              maxMonthYear[\"month\"] = numberMonth;\n            } else if (numberYear === maxMonthYear[\"year\"] || numberYear === minMonthYear[\"year\"]) {\n              if (numberMonth < minMonthYear[\"month\"]) {\n                // this is the new minimum\n                minMonthYear[\"month\"] = numberMonth;\n              }\n\n              if (numberMonth > maxMonthYear[\"month\"]) {\n                maxMonthYear[\"month\"] = numberMonth;\n              }\n            }\n          }\n        }\n      } // build whole timelines\n\n\n      var timeLinesDict = buildTimeLine(minMonthYear, maxMonthYear);\n      timeLine = timeLinesDict[\"timeLine\"];\n      timeLineOfZeros = timeLinesDict[\"timeLineZeros\"];\n      var dictOfCitiesTimeLineValues = {};\n      var cities_arr = [];\n      var valuesArrOfArr = []; // cycle all the cities\n\n      for (var city_key in json) {\n        var allDataOfCity = json[city_key]; // get the data for one city\n\n        var sourcesForCity = []; // this will contain the different source names for a city\n        // cycle all the sources\n\n        for (var datasource_key in allDataOfCity) {\n          var dataOfOneSource = [];\n          sourcesForCity.push(datasource_key); // push the name of the source to the list \n\n          dataOfOneSource = allDataOfCity[datasource_key]; // this is the data from one source \n\n          var totalDataForOneSouce = []; // cycle the data from one source \n\n          for (var year_key in dataOfOneSource) {\n            var numberYear = parseInt(year_key);\n            var oneYearData = dataOfOneSource[year_key];\n            var yearlyDataValues = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n            for (var month_key in oneYearData) {\n              var numberMonth = parseInt(month_key);\n              yearlyDataValues[numberMonth] = oneYearData[month_key];\n            } // this is not correct, years are not continuous\n\n\n            totalDataForOneSouce = totalDataForOneSouce.concat(yearlyDataValues);\n          } // end for on years\n\n\n          valuesArrOfArr.push(totalDataForOneSouce);\n        } // end for one source\n        //console.log(totalDataForOneSouce)\n\n\n        var timeLine = buildTimeLine(minMonthYear, maxMonthYear); // cycle through all the sources found and create the names for each aggregate\n\n        for (var i in sourcesForCity) {\n          cities_arr.push(city_key + \" \" + sourcesForCity[i]); //console.log(sourcesForCity[i])\n        }\n      } // end for on cities\n\n\n      dictOfCitiesTimeLineValues[\"cities\"] = cities_arr;\n      dictOfCitiesTimeLineValues[\"timeLine\"] = timeLine;\n      dictOfCitiesTimeLineValues[\"values\"] = valuesArrOfArr;\n      return dictOfCitiesTimeLineValues;\n    }\n\n    const dictfromjson = arrayConvert(cdmData);\n    console.log(dictfromjson[\"cities\"]);\n    console.log(dictfromjson[\"timeLine\"]);\n    console.log(dictfromjson[\"values\"]);\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: /*#__PURE__*/_jsxDEV(Heatmap, {\n        values: dictfromjson[\"values\"],\n        cities: dictfromjson[\"cities\"],\n        timeLine: dictfromjson[\"timeLine\"]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 131,\n        columnNumber: 13\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 130,\n      columnNumber: 13\n    }, this);\n  }\n}\n\n_s(JsonParse, \"Rp4szxWOApMRlsnq1bYja4ln4n8=\");\n\n_c = JsonParse;\nexport default JsonParse;\n\nvar _c;\n\n$RefreshReg$(_c, \"JsonParse\");","map":{"version":3,"sources":["/Users/brendanpolidori/Desktop/project_repos/my-react.nosync/learn-react/src/components/JsonParse.js"],"names":["React","useState","useEffect","axios","Heatmap","JsonParse","cdmData","setCdmData","get","then","res","data","catch","err","console","log","buildTimeLine","minimumMonthYear","maximumMonthYear","dictOfTimeLines","timeLineArray","timeLineOfZeros","year","month","push","topush","toString","minMonthYear","maxMonthYear","arrayConvert","json","city_key","datasource_key","allDataOfCity","year_key","dataOfOneSource","month_key","oneYearData","numberMonth","parseInt","numberYear","timeLinesDict","timeLine","dictOfCitiesTimeLineValues","cities_arr","valuesArrOfArr","sourcesForCity","totalDataForOneSouce","yearlyDataValues","concat","i","dictfromjson"],"mappings":"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","sourcesContent":["import React, { useState, useEffect } from 'react'\nimport axios from 'axios'\nimport Heatmap from './plots/Heatmap'\n\nfunction JsonParse() {\n\n        const [cdmData, setCdmData] = useState([])\n\n        useEffect(() => {\n            axios\n                .get(`http://127.0.0.1:5000/api_cdm/available_data_test`)\n                //.get(`http://127.0.0.1:5000/api_cdm/available_data`)\n                .then(res => {\n                    // console.log(res)\n                    setCdmData(res.data)\n                })\n                .catch(err => {\n                    console.log(err)\n                })\n        }, [])\n        console.log(cdmData)\n\n        function buildTimeLine(minimumMonthYear,maximumMonthYear) {\n            var dictOfTimeLines = {}\n            var timeLineArray = []\n            var timeLineOfZeros = []\n            for (let year = minimumMonthYear[\"year\"]; year <= maximumMonthYear[\"year\"]; year++) {\n                for (let month = 1; month < 13; month++) {\n                    timeLineOfZeros.push(0)\n                    if (month < 10) {\n                        var topush = \"0\"+month.toString()  + \"-\" + year.toString()\n                    }else{\n                        var topush = month.toString()  + \"-\" + year.toString()\n                    }\n                    timeLineArray.push(topush)\n                }\n            }\n            dictOfTimeLines[\"timeLine\"] = timeLineArray\n            dictOfTimeLines[\"timeLineZeros\"] = timeLineOfZeros\n\n            return dictOfTimeLines;\n        }\n\n        var minMonthYear = {\"year\":3000,\"month\":12}\n        var maxMonthYear = {\"year\":0,\"month\":0}\n\n        function arrayConvert(json){\n            // read the whole json once to find the whole timeline, it's ugly but should work\n            for(var city_key in json){\n                for(var datasource_key in allDataOfCity){\n                    for (var year_key in dataOfOneSource) {\n                    for (var month_key in oneYearData) {\n                            var numberMonth = parseInt(month_key)\n                            // check min and max values of the dates\n                            if (   numberYear < minMonthYear[\"year\"]  ) {\n                                minMonthYear[\"year\"] = numberYear\n                                minMonthYear[\"month\"] = numberMonth\n                            } else if (  numberYear > maxMonthYear[\"year\"] ) {\n                                // new maximum\n                                maxMonthYear[\"year\"] = numberYear\n                                maxMonthYear[\"month\"] = numberMonth\n                            } else if(numberYear === maxMonthYear[\"year\"] || numberYear === minMonthYear[\"year\"] ) {\n                                if (numberMonth < minMonthYear[\"month\"]) {\n                                    // this is the new minimum\n                                    minMonthYear[\"month\"] = numberMonth\n                                }\n                                if (numberMonth > maxMonthYear[\"month\"]) {\n                                    maxMonthYear[\"month\"] = numberMonth\n                                }\n                            }\n                        }\n                    }\n                }\n            // build whole timelines\n            var timeLinesDict = buildTimeLine(minMonthYear,maxMonthYear)\n            timeLine = timeLinesDict[\"timeLine\"]\n            timeLineOfZeros = timeLinesDict[\"timeLineZeros\"]\n            var dictOfCitiesTimeLineValues = {}\n            var cities_arr = [];\n            var valuesArrOfArr = [];\n            // cycle all the cities\n            for(var city_key in json){\n                var allDataOfCity = json[city_key]; // get the data for one city\n                var sourcesForCity = []; // this will contain the different source names for a city\n                // cycle all the sources\n                for(var datasource_key in allDataOfCity){\n                    var dataOfOneSource = []\n                    sourcesForCity.push(datasource_key) // push the name of the source to the list \n                    dataOfOneSource = allDataOfCity[datasource_key] // this is the data from one source \n                    var totalDataForOneSouce = []\n                    // cycle the data from one source \n                    for (var year_key in dataOfOneSource) {\n                        var numberYear = parseInt(year_key)\n\n                        var oneYearData = dataOfOneSource[year_key]\n                        var yearlyDataValues = [0,0,0,0,0,0,0,0,0,0,0,0]\n\n                        for (var month_key in oneYearData) {\n                            var numberMonth = parseInt(month_key)\n                            yearlyDataValues[numberMonth] = oneYearData[month_key]\n                        }\n                        // this is not correct, years are not continuous\n                        totalDataForOneSouce = totalDataForOneSouce.concat(yearlyDataValues)\n    \n                    }// end for on years\n\n                    valuesArrOfArr.push(totalDataForOneSouce)\n                }// end for one source\n                //console.log(totalDataForOneSouce)\n                var timeLine = buildTimeLine(minMonthYear,maxMonthYear)\n\n                // cycle through all the sources found and create the names for each aggregate\n                for(var i in sourcesForCity){\n                    cities_arr.push(city_key + \" \" + sourcesForCity[i]);\n                    //console.log(sourcesForCity[i])\n                }\n                \n            }// end for on cities\n            dictOfCitiesTimeLineValues[\"cities\"] = cities_arr;\n            dictOfCitiesTimeLineValues[\"timeLine\"] = timeLine;\n            dictOfCitiesTimeLineValues[\"values\"] = valuesArrOfArr;\n            return dictOfCitiesTimeLineValues;\n        }\n        const dictfromjson = arrayConvert(cdmData)\n        \n        console.log(dictfromjson[\"cities\"])\n        console.log(dictfromjson[\"timeLine\"])\n        console.log(dictfromjson[\"values\"])\n        return (\n            <div>\n            <Heatmap values = {dictfromjson[\"values\"]} cities = {dictfromjson[\"cities\"]} timeLine = {dictfromjson[\"timeLine\"]}  ></Heatmap>\n            </div>\n        )\n    }\n}\n\nexport default JsonParse"]},"metadata":{},"sourceType":"module"}